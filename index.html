<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stress–Strain Simulator (Tension)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background:#f6f7fb; color:#111; }
    header { padding: 16px 20px; background:#fff; border-bottom:1px solid #e6e8f0; }
    header h1 { margin: 0; font-size: 18px; }
    header p { margin: 6px 0 0; color:#444; font-size: 13px; line-height: 1.35; }
    .wrap { display:grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    .card { background:#fff; border:1px solid #e6e8f0; border-radius: 14px; box-shadow: 0 2px 10px rgba(0,0,0,.03); }
    .panel { padding: 14px; }
    .panel h2 { font-size: 14px; margin: 0 0 10px; }
    .group { margin: 12px 0; }
    .group label { display:block; font-size: 12px; color:#333; margin-bottom: 6px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    select, button {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid #cfd6e6;
      background: #fff;
      font-size: 14px;
    }
    .row > button { flex: 1; }
    button {
      cursor: pointer;
      background: #1f6feb;
      color: #fff;
      border: 1px solid #1f6feb;
      transition: transform .02s ease, filter .15s ease;
      font-weight: 600;
    }
    button:active { transform: translateY(1px); }
    button.secondary { background:#fff; color:#1f6feb; border-color:#cfd6e6; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .status {
      padding: 10px 12px;
      background: #f1f5ff;
      border: 1px solid #d8e3ff;
      border-radius: 12px;
      font-size: 13px;
      color:#20315a;
      line-height: 1.35;
    }
    .status b { color:#111; }
    .canvasWrap { padding: 14px; }
    canvas { width: 100%; height: 520px; background: #fbfcff; border:1px solid #e6e8f0; border-radius: 14px; }
    .note { font-size: 12px; color:#555; margin-top: 10px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    /* Legend box */
    .legendBox{
      margin-top: 10px;
      padding: 10px 12px;
      border: 1px solid #e6e8f0;
      border-radius: 12px;
      background: #fff;
      font-size: 12px;
      color: #333;
      display: inline-block;
      min-width: 280px;
    }
    .legendRow{
      display:flex;
      align-items:center;
      gap:10px;
      margin: 6px 0;
    }
    .legendSwatch{
      width: 34px;
      height: 0;
      border-top: 4px solid #1f6feb;
      border-radius: 6px;
      flex: 0 0 auto;
    }
    .legendSwatch.dashed{ border-top-style: dashed; }
    .legendX{
      width: 34px; height: 18px; position: relative; flex: 0 0 auto;
    }
    .legendX::before,.legendX::after{
      content:""; position:absolute; left:50%; top:50%;
      width:28px; height:0; border-top:4px solid #c62828; transform-origin:center;
    }
    .legendX::before{ transform: translate(-50%,-50%) rotate(45deg); }
    .legendX::after { transform: translate(-50%,-50%) rotate(-45deg); }
    .legendTitle{ font-weight:700; margin-bottom:6px; color:#111; }
    .legendMuted{ color:#555; }
    .checkline{
      display:flex; align-items:center; gap:10px;
      font-size: 13px; color:#222; user-select:none;
    }
    .checkline input{ width:auto; }
  </style>
</head>

<body>
  <header>
    <h1>Stress–Strain Simulator (Tensile Forces)</h1>
    <p>
      In this simulation, the object is undergoing <b>tension</b> (tensile forces pulling it apart).
      Choose a material, a loading rate, and a stress level, then run the iterations to see deformation and failure.
    </p>
  </header>

  <main class="wrap">
    <section class="card panel">
      <h2>Student Controls</h2>

      <div class="group">
        <label for="material">1) Select object (material)</label>
        <select id="material">
          <option value="silly">Silly Putty (viscoelastic)</option>
          <option value="ice">Ice (brittle)</option>
        </select>
      </div>

      <div class="group">
        <label for="rate">2) Select rate</label>
        <select id="rate">
          <option value="slow">Slow</option>
          <option value="fast">Fast</option>
        </select>
      </div>

      <div class="group">
        <label for="stress">3) Select stress level</label>
        <select id="stress">
          <option value="low">Low stress</option>
          <option value="high">High stress</option>
        </select>
      </div>

      <div class="group">
        <label class="checkline">
          <input type="checkbox" id="overlayBoth" />
          Overlay both materials (ice + silly putty)
        </label>
      </div>

      <div class="group">
        <div class="row">
          <button id="runBtn">Run Simulation</button>
          <button class="secondary" id="stepBtn">Step Once</button>
        </div>
      </div>

      <div class="group">
        <div class="row">
          <button class="secondary" id="resetBtn">Reset</button>
          <button class="secondary" id="pauseBtn" disabled>Pause</button>
        </div>
      </div>

      <div class="group status" id="status">
        <b>Status:</b> Loading images…<br />
        Iteration: <span class="mono" id="iterText">0</span><br />
        Mode: <span class="mono" id="modeText">—</span>
      </div>

      <p class="note">
        <b>Photo mode:</b> the ellipse is filled by a real image texture (ice or silly putty) clipped to the current shape.
        Green dots are the four points. “Broken” shows fracture under tension.
      </p>
    </section>

    <section class="card canvasWrap">
      <canvas id="c"></canvas>
      <div class="legendBox" id="legendBox" aria-label="Legend"></div>
    </section>
  </main>

  <script>
    // ✅ Make sure these filenames match EXACTLY what is in your repo (case-sensitive)
    const ICE_SRC   = "./ice.png";
    const SILLY_SRC = "./sillyputty.png";

    // Updated iteration points: ordered top, right, bottom, left
    const SHAPES = [
      { name: "0", pts: [{x:0,y:5},{x:5,y:0},{x:0,y:-5},{x:-5,y:0}] },
      { name: "1", pts: [{x:0,y:4},{x:6,y:0},{x:0,y:-4},{x:-6,y:0}] },
      { name: "2", pts: [{x:0,y:3},{x:7,y:0},{x:0,y:-3},{x:-7,y:0}] },
      { name: "3", pts: [{x:0,y:2},{x:8,y:0},{x:0,y:-2},{x:-8,y:0}] }
    ];

    // Failure rules: store "break after shape index" (3 => break on 4th, 1 => break on 2nd)
    const BREAK_AFTER_SHAPE_INDEX = {
      silly: { slow: { low: 3, high: 3 }, fast: { low: 3, high: 1 } },
      ice:   { slow: { low: 3, high: 1 }, fast: { low: 1, high: 1 } }
    };

    const materialEl = document.getElementById("material");
    const rateEl = document.getElementById("rate");
    const stressEl = document.getElementById("stress");
    const overlayEl = document.getElementById("overlayBoth");

    const runBtn = document.getElementById("runBtn");
    const stepBtn = document.getElementById("stepBtn");
    const resetBtn = document.getElementById("resetBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    const statusEl = document.getElementById("status");
    const iterText = document.getElementById("iterText");
    const modeText = document.getElementById("modeText");
    const legendBoxEl = document.getElementById("legendBox");

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const IMG = { ice: null, silly: null };
    let imagesReady = false;

    let frame = 0;
    let timer = null;

    function breakAfterIndexFor(material) {
      return BREAK_AFTER_SHAPE_INDEX[material][rateEl.value][stressEl.value];
    }
    function stopFrameForSelected() {
      return breakAfterIndexFor(materialEl.value) + 1;
    }
    function stateFor(material, frameNumber) {
      const bAfter = breakAfterIndexFor(material);
      if (frameNumber <= bAfter) return { type: "shape", idx: Math.min(frameNumber, SHAPES.length - 1) };
      return { type: "broken" };
    }

    function rateMs() { return (rateEl.value === "fast") ? 450 : 1100; }

    function modeString() {
      return `${materialEl.options[materialEl.selectedIndex].text} • ${rateEl.value.toUpperCase()} • ${stressEl.value.toUpperCase()}`;
    }
    function materialBehaviorText() {
      return (materialEl.value === "silly")
        ? "Silly Putty: viscoelastic — response depends strongly on loading rate."
        : "Ice: brittle — more likely to fracture with less deformation, especially at higher stress or faster loading.";
    }
    function tensileNote() {
      return "Tensile forces pull upward/downward, stretching the object along the vertical axis.";
    }

    function materialLabel(material) { return material === "silly" ? "Silly putty" : "Ice"; }
    function lineColorFor(material, isOverlay) {
      if (material === "silly") return isOverlay ? "rgba(31,111,235,0.45)" : "rgba(31,111,235,0.90)";
      return isOverlay ? "rgba(31,111,235,0.30)" : "rgba(31,111,235,0.70)";
    }

    function updateLegend() {
      const selected = materialEl.value;
      const other = (selected === "silly") ? "ice" : "silly";
      const overlayOn = overlayEl.checked;

      const selectedColor = lineColorFor(selected, false);
      const overlayColor  = lineColorFor(other, true);

      legendBoxEl.innerHTML = `
        <div class="legendTitle">Legend</div>
        <div class="legendRow">
          <span class="legendSwatch" style="border-top-color:${selectedColor}"></span>
          <div><b>Selected material:</b> ${materialLabel(selected)} (solid)</div>
        </div>
        <div class="legendRow">
          <span class="legendSwatch dashed" style="border-top-color:${overlayColor}; opacity:${overlayOn ? 1 : 0.35}"></span>
          <div>
            <b>Overlay material:</b> ${materialLabel(other)} (dashed)
            <span class="legendMuted">${overlayOn ? "" : " — overlay off"}</span>
          </div>
        </div>
        <div class="legendRow">
          <span class="legendX" aria-hidden="true"></span>
          <div><b>Broken state:</b> fracture under tension</div>
        </div>
      `;
    }

    function setStatus(stateWord = "Ready.") {
      const stopAt = stopFrameForSelected();
      const isBrokenNow = frame >= stopAt;

      iterText.textContent = isBrokenNow ? "broken" : frame.toString();
      modeText.textContent = modeString();

      const bIndex = breakAfterIndexFor(materialEl.value);
      const planLine = (bIndex === 3)
        ? "Planned: show iterations 0→3, then BROKEN (break on 4th iteration)."
        : "Planned: show iterations 0→1, then BROKEN (break on 2nd iteration).";

      statusEl.innerHTML =
        `<b>Status:</b> ${stateWord}<br/>` +
        `Iteration: <span class="mono">${iterText.textContent}</span><br/>` +
        `Mode: <span class="mono">${modeText.textContent}</span><br/>` +
        `<span class="mono">${planLine}</span><br/>` +
        `<span class="mono">${materialBehaviorText()}</span><br/>` +
        `<span class="mono">${tensileNote()}</span>`;

      updateLegend();
    }

    // High-DPI crisp canvas
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }
    window.addEventListener("resize", resizeCanvas);

    // Equidistant axes: one uniform scale
    function worldToCanvas(x, y) {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      const padding = 60;
      const worldMin = -10, worldMax = 10;
      const worldSize = worldMax - worldMin;

      const usableW = w - padding * 2;
      const usableH = h - padding * 2;
      const scale = Math.min(usableW, usableH) / worldSize;

      const cx0 = w / 2, cy0 = h / 2;
      return { cx: cx0 + x * scale, cy: cy0 - y * scale };
    }

    function drawAxes() {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx.save();
      ctx.clearRect(0, 0, w, h);

      // Grid
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 1;
      for (let i = -10; i <= 10; i += 1) {
        const p1 = worldToCanvas(i, -10), p2 = worldToCanvas(i, 10);
        ctx.beginPath(); ctx.moveTo(p1.cx, p1.cy); ctx.lineTo(p2.cx, p2.cy); ctx.stroke();

        const q1 = worldToCanvas(-10, i), q2 = worldToCanvas(10, i);
        ctx.beginPath(); ctx.moveTo(q1.cx, q1.cy); ctx.lineTo(q2.cx, q2.cy); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = "rgba(0,0,0,0.45)";
      ctx.lineWidth = 2;
      const x0 = worldToCanvas(-10, 0), x1 = worldToCanvas(10, 0);
      ctx.beginPath(); ctx.moveTo(x0.cx, x0.cy); ctx.lineTo(x1.cx, x1.cy); ctx.stroke();

      const y0 = worldToCanvas(0, -10), y1 = worldToCanvas(0, 10);
      ctx.beginPath(); ctx.moveTo(y0.cx, y0.cy); ctx.lineTo(y1.cx, y1.cy); ctx.stroke();

      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("x", x1.cx - 12, x1.cy - 6);
      ctx.fillText("y", y1.cx + 6, y1.cy + 12);

      ctx.restore();
    }

    function drawTensionArrows() {
      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.lineWidth = 2;

      const top = worldToCanvas(0, 9.5);
      const bot = worldToCanvas(0, -9.5);

      // Up arrow
      ctx.beginPath(); ctx.moveTo(top.cx - 70, top.cy + 25); ctx.lineTo(top.cx - 70, top.cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(top.cx - 78, top.cy + 8); ctx.lineTo(top.cx - 70, top.cy); ctx.lineTo(top.cx - 62, top.cy + 8); ctx.stroke();

      // Down arrow
      ctx.beginPath(); ctx.moveTo(bot.cx - 70, bot.cy - 25); ctx.lineTo(bot.cx - 70, bot.cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(bot.cx - 78, bot.cy - 8); ctx.lineTo(bot.cx - 70, bot.cy); ctx.lineTo(bot.cx - 62, bot.cy - 8); ctx.stroke();

      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillText("tension", top.cx - 110, (top.cy + bot.cy) / 2);
      ctx.restore();
    }

    async function loadImage(src) {
      return new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Failed to load image: " + src));
        im.src = src;
      });
    }

    async function preloadImages() {
      // If these fail, your filenames/path/case don't match the repo
      IMG.ice = await loadImage(ICE_SRC);
      IMG.silly = await loadImage(SILLY_SRC);
      imagesReady = true;
      setStatus("Ready.");
      draw();
    }

    function ellipseCanvasParamsFromPoints(pts) {
      const top = pts[0], right = pts[1], bottom = pts[2], left = pts[3];
      const rx = Math.max(Math.abs(right.x), Math.abs(left.x));
      const ry = Math.max(Math.abs(top.y), Math.abs(bottom.y));

      const center = worldToCanvas(0, 0);
      const xEdge = worldToCanvas(rx, 0);
      const yEdge = worldToCanvas(0, ry);

      const canvasRx = Math.abs(xEdge.cx - center.cx);
      const canvasRy = Math.abs(yEdge.cy - center.cy);

      return { cx: center.cx, cy: center.cy, canvasRx, canvasRy };
    }

    function drawPointsAndLabels(pts) {
      ctx.save();
      ctx.fillStyle = "rgba(10,122,59,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 1;
      for (const p of pts) {
        const c = worldToCanvas(p.x, p.y);
        ctx.beginPath();
        ctx.arc(c.cx, c.cy, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      for (const p of pts) {
        const c = worldToCanvas(p.x, p.y);
        ctx.fillText(`(${p.x},${p.y})`, c.cx + 10, c.cy - 10);
      }
      ctx.restore();
    }

    function drawBrokenAtCenter(alpha = 1) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = "rgba(198,40,40,1.0)";
      ctx.lineWidth = 5;

      const a = worldToCanvas(-4, 6);
      const b = worldToCanvas(4, -6);
      const c = worldToCanvas(4, 6);
      const d = worldToCanvas(-4, -6);

      ctx.beginPath(); ctx.moveTo(a.cx, a.cy); ctx.lineTo(b.cx, b.cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(c.cx, c.cy); ctx.lineTo(d.cx, d.cy); ctx.stroke();

      ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(198,40,40,1.0)";
      ctx.fillText("BROKEN", 18, 28);
      ctx.restore();
    }

    function drawPhotoClippedEllipse(material, iterIdx, dashed, opacity) {
      const pts = SHAPES[iterIdx].pts;
      const { cx, cy, canvasRx, canvasRy } = ellipseCanvasParamsFromPoints(pts);

      const im = (material === "ice") ? IMG.ice : IMG.silly;
      if (!im) return;

      // Clip ellipse and draw image inside
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.ellipse(cx, cy, canvasRx, canvasRy, 0, 0, Math.PI*2);
      ctx.clip();

      // Cover-fill ellipse bounds with center-crop
      const targetW = canvasRx * 2;
      const targetH = canvasRy * 2;

      const imgAspect = im.width / im.height;
      const tgtAspect = targetW / targetH;

      let sx=0, sy=0, sw=im.width, sh=im.height;
      if (imgAspect > tgtAspect) {
        sh = im.height;
        sw = Math.round(sh * tgtAspect);
        sx = Math.round((im.width - sw) / 2);
      } else {
        sw = im.width;
        sh = Math.round(sw / tgtAspect);
        sy = Math.round((im.height - sh) / 2);
      }

      ctx.drawImage(im, sx, sy, sw, sh, cx - canvasRx, cy - canvasRy, targetW, targetH);

      // Subtle inner shadow for depth
      const grad = ctx.createRadialGradient(cx, cy, Math.min(canvasRx, canvasRy)*0.2, cx, cy, Math.max(canvasRx, canvasRy));
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0,0.12)");
      ctx.fillStyle = grad;
      ctx.fillRect(cx - canvasRx, cy - canvasRy, targetW, targetH);

      ctx.restore();

      // Outline
      ctx.save();
      if (dashed) ctx.setLineDash([10, 8]);
      ctx.lineWidth = 4;
      ctx.strokeStyle = lineColorFor(material, dashed);
      ctx.beginPath();
      ctx.ellipse(cx, cy, canvasRx, canvasRy, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      drawPointsAndLabels(pts);
    }

    function drawMaterial(material, st, dashed = false) {
      const opacity = dashed ? 0.60 : 1.0;

      if (!imagesReady) {
        // Fallback: outline only if images not loaded
        if (st.type === "shape") {
          const pts = SHAPES[st.idx].pts;
          const { cx, cy, canvasRx, canvasRy } = ellipseCanvasParamsFromPoints(pts);
          ctx.save();
          if (dashed) ctx.setLineDash([10, 8]);
          ctx.lineWidth = 4;
          ctx.strokeStyle = lineColorFor(material, dashed);
          ctx.beginPath();
          ctx.ellipse(cx, cy, canvasRx, canvasRy, 0, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          drawPointsAndLabels(pts);
        } else {
          drawBrokenAtCenter(dashed ? 0.45 : 1.0);
        }
        return;
      }

      if (st.type === "broken") {
        drawBrokenAtCenter(dashed ? 0.45 : 1.0);
        return;
      }

      drawPhotoClippedEllipse(material, st.idx, dashed, opacity);

      ctx.save();
      ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.fillText(`${materialLabel(material)}: iter ${st.idx}`, 18, 22 + (material === "ice" ? 16 : 0));
      ctx.restore();
    }

    function draw() {
      drawAxes();
      drawTensionArrows();

      const selected = materialEl.value;
      const other = (selected === "silly") ? "ice" : "silly";

      const selectedState = stateFor(selected, frame);
      const otherState = stateFor(other, frame);

      drawMaterial(selected, selectedState, false);
      if (overlayEl.checked) drawMaterial(other, otherState, true);
    }

    function stopTimer() {
      if (timer) { clearInterval(timer); timer = null; }
      pauseBtn.disabled = true;
      pauseBtn.textContent = "Pause";
      runBtn.disabled = false;
      stepBtn.disabled = false;
    }

    function nextStep() {
      const stopAt = stopFrameForSelected();
      if (frame >= stopAt) {
        setStatus("Finished.");
        draw();
        stopTimer();
        return;
      }

      frame += 1;
      setStatus("Running…");
      draw();

      if (frame >= stopAt) {
        setStatus("Finished.");
        stopTimer();
      }
    }

    function runSimulation() {
      stopTimer();
      setStatus("Running…");
      runBtn.disabled = true;
      stepBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.textContent = "Pause";
      timer = setInterval(() => nextStep(), rateMs());
    }

    function pauseResume() {
      if (!timer) {
        setStatus("Resumed…");
        runBtn.disabled = true;
        stepBtn.disabled = true;
        pauseBtn.textContent = "Pause";
        pauseBtn.disabled = false;
        timer = setInterval(() => nextStep(), rateMs());
        return;
      }
      clearInterval(timer);
      timer = null;
      setStatus("Paused.");
      pauseBtn.textContent = "Resume";
      runBtn.disabled = false;
      stepBtn.disabled = false;
    }

    function reset() {
      stopTimer();
      frame = 0;
      setStatus(imagesReady ? "Ready." : "Loading images…");
      draw();
    }

    runBtn.addEventListener("click", runSimulation);
    stepBtn.addEventListener("click", () => { stopTimer(); nextStep(); });
    pauseBtn.addEventListener("click", pauseResume);
    resetBtn.addEventListener("click", reset);
    [materialEl, rateEl, stressEl, overlayEl].forEach(el => el.addEventListener("change", reset));

    // Init
    resizeCanvas();
    setStatus("Loading images…");
    updateLegend();

    preloadImages().catch(err => {
      console.error(err);
      imagesReady = false;
      setStatus("Could not load images. Check filenames/case: ./ice.png and ./sillyputty.png");
      draw();
    });
  </script>
</body>
</html>
